pipelines:
  branches:
    dev:
      - step:
          name: 1. ðŸ—ï¸ Build and Push Docker Image
          runs-on:
            - self.hosted
            - linux.shell
          script:
            # --- Set the correct Docker host ---
            - export DOCKER_HOST_PATH="unix:///var/run/docker.sock"
            - docker -H $DOCKER_HOST_PATH info || (echo "âŒ Docker daemon not reachable." && exit 1)
            
            # --- 1. Set Image Details ---
            - export IMAGE_NAME="${DOCKERHUB_USERNAME}/automation-project"
            - export VERSION="prod-0.1.${BITBUCKET_BUILD_NUMBER}"
            - export VERSIONED_IMAGE="${IMAGE_NAME}:${VERSION}"

            # --- 2. Login to Docker Hub ---
            - echo "$DOCKERHUB_PASSWORD" | docker -H $DOCKER_HOST_PATH login -u "$DOCKERHUB_USERNAME" --password-stdin

            # --- 3. Build, Tag, and Push ---
            - echo "ðŸš€ Building and pushing ${VERSIONED_IMAGE}..."
            - docker -H $DOCKER_HOST_PATH build -t "${IMAGE_NAME}:latest" .
            - docker -H $DOCKER_HOST_PATH tag "${IMAGE_NAME}:latest" "${VERSIONED_IMAGE}"
            - docker -H $DOCKER_HOST_PATH push "${IMAGE_NAME}:latest"
            - docker -H $DOCKER_HOST_PATH push "${VERSIONED_IMAGE}"
            - echo "âœ… Image pushed successfully!"
            - echo "${VERSIONED_IMAGE}" > image_name.txt
          artifacts:
            - image_name.txt

      - step:
          name: 2. âš ï¸ Check for DB Migrations (Manual)
          trigger: manual
          runs-on:
            - self.hosted
            - linux.shell
          script:
            - echo "------------------------------------------------------"
            - echo "This deploy is for latest version"
            - echo "Did you run any backward-compatible database migrations?"
            - echo "If this change requires a DB migration, run it now."
            - echo "Press 'Run' to confirm you have checked."
            - echo "------------------------------------------------------"
          artifacts:
            - image_name.txt # Pass artifact along

      - step:
          name: 3. ðŸš€ Deploy to Idle Environment
          runs-on:
            - self.hosted
            - linux.shell
          script:
            # --- 1. Define files and get new image name ---
            - export K8S_SERVICE_PATH="k8s/service.yaml"
            - export DEPLOY_BLUE_PATH="k8s/deployment-blue.yaml"
            - export DEPLOY_GREEN_PATH="k8s/deployment-green.yaml"
            - export NEW_IMAGE=$(cat image_name.txt)
            
            # --- 2. Find which version is LIVE and which is IDLE ---
            - export LIVE_VERSION_LABEL=$(kubectl get svc automation-project-service -o=jsonpath='{.spec.selector.version}')
            - if [ "$LIVE_VERSION_LABEL" == "blue" ]; then
            -   export TARGET_VERSION_LABEL="green"
            -   export TARGET_DEPLOYMENT_PATH="$DEPLOY_GREEN_PATH"
            - else
            -   export TARGET_VERSION_LABEL="blue"
            -   export TARGET_DEPLOYMENT_PATH="$DEPLOY_BLUE_PATH"
            - fi
            
            # --- MAO NI ANG MGA KULANG NGA PART ---
            - echo "ðŸŽ¯ Deploying new image to idle environment"

            # --- 3. Clean (fix BOM error) and update the IDLE deployment ---
            - sed -i '1s/^\xEF\xBB\xBF//' "${TARGET_DEPLOYMENT_PATH}"
            - yq e ".spec.template.spec.containers[0].image = \"${NEW_IMAGE}\"" -i "${TARGET_DEPLOYMENT_PATH}"
            - kubectl apply -f "${TARGET_DEPLOYMENT_PATH}"

            # --- 4. Wait for the IDLE deployment to be ready ---
            - kubectl rollout status deployment/automation-project-${TARGET_VERSION_LABEL}
            - echo "âœ… ${TARGET_VERSION_LABEL} deployment is ready for testing."
            - echo "${TARGET_VERSION_LABEL}" > new_live_version.txt
            # --- END SA KULANG NGA PART ---
          artifacts:
            - new_live_version.txt

      - step:
          name: 4. ðŸ§ª Run Automated Smoke Tests
          runs-on:
            - self.hosted
            - linux.shell
          script:
            # --- 1. Get the idle version we need to test ---
            - export TARGET_VERSION_LABEL=$(cat new_live_version.txt)
            
            # --- 2. Set the correct test URL and Ingress file ---
            - if [ "$TARGET_VERSION_LABEL" == "blue" ]; then
            -   export TEST_URL="http://test-blue.karl.com"
            -   export TEST_INGRESS_YAML="k8s/ingress-test-blue.yaml"
            - else
            -   export TEST_URL="http://test-green.karl.com"
            -   export TEST_INGRESS_YAML="k8s/ingress-test-green.yaml"
            - fi

            # --- 3. Apply the internal test Ingress rule ---
            - sed -i '1s/^\xEF\xBB\xBF//' "${TEST_INGRESS_YAML}"
            - kubectl apply -f "${TEST_INGRESS_YAML}"
            - echo "Waiting for Ingress rule to be ready..."
            - sleep 10 # Ingress rules can take a few seconds

            # --- 4. Ensure the test script is executable ---
            - chmod +x k8s/smoke-test.sh

            # --- 5. Run the advanced smoke test script ---
            - bash k8s/smoke-test.sh "${TEST_URL}"
            - echo "âœ… Automated smoke test passed!"
          artifacts:
            - new_live_version.txt # Pass along artifact

      - step:
          name: 5. ðŸ”„ Promote to Live (Manual Click)
          trigger: manual
          runs-on:
            - self.hosted
            - linux.shell
          script:
            # --- 1. Define all live files ---
            - export K8S_SERVICE_PATH="k8s/service.yaml"
            - export HPA_PATH="k8s/hpa.yaml"
            - export LIVE_INGRESS_PATH="k8s/ingress-live.yaml"
            
            - export NEW_LIVE_VERSION=$(cat new_live_version.txt) # e.g., "blue"
            - export NEW_LIVE_DEPLOYMENT="automation-project-${NEW_LIVE_VERSION}"

            # --- 2. "Flip the switch" for the Service (ANG DAAN NGA LOGIC) ---
            - echo "ðŸ”„ Switching live traffic to ${NEW_LIVE_VERSION}..."
            - sed -i '1s/^\xEF\xBB\xBF//' "${K8S_SERVICE_PATH}"
            - yq e ".spec.selector.version = \"${NEW_LIVE_VERSION}\"" -i "${K8S_SERVICE_PATH}"
            - kubectl apply -f "${K8S_SERVICE_PATH}"

            # --- 3. "Flip the switch" for the HPA ---
            - sed -i '1s/^\xEF\xBB\xBF//' "${HPA_PATH}"
            - yq e ".spec.scaleTargetRef.name = \"${NEW_LIVE_DEPLOYMENT}\"" -i "${HPA_PATH}"
            - kubectl apply -f "${HPA_PATH}"
            
            # --- 4. Apply the Live Ingress rule ---
            - sed -i '1s/^\xEF\xBB\xBF//' "${LIVE_INGRESS_PATH}"
            - kubectl apply -f "${LIVE_INGRESS_PATH}"

            # --- 5. Add grace period ---
            - echo "âœ… Cut-over complete! Waiting 30s for old connections to drain..."
            - sleep 30
            - echo "âœ… Promotion to ${NEW_LIVE_VERSION} is fully complete."

  custom: # --- This is the automated rollback pipeline ---
    rollback-to-idle:
      - step:
          name: ðŸ”„ Automated Rollback
          runs-on:
            - self.hosted
            - linux.shell
          script:
            - export K8S_SERVICE_PATH="k8s/service.yaml"
            - export HPA_PATH="k8s/hpa.yaml"
            
            # --- 1. Find what is LIVE and what is IDLE ---
            - export LIVE_VERSION_LABEL=$(kubectl get svc automation-project-service -o=jsonpath='{.spec.selector.version}')
            - if [ "$LIVE_VERSION_LABEL" == "blue" ]; then
            -   export ROLLBACK_VERSION_LABEL="green"
            - else
            -   export ROLLBACK_VERSION_LABEL="blue"
            - fi
            - export ROLLBACK_DEPLOYMENT="automation-project-${ROLLBACK_VERSION_LABEL}"

            - echo "ðŸ”¥ EMERGENCY ROLLBACK"

            # --- 2. "Flip the switch" for the Service ---
            - sed -i '1s/^\xEF\xBB\xBF//' "${K8S_SERVICE_PATH}"
            - yq e ".spec.selector.version = \"${ROLLBACK_VERSION_LABEL}\"" -i "${K8S_SERVICE_PATH}"
            - kubectl apply -f "${K8S_SERVICE_PATH}"

            # --- 3. "Flip the switch" for the HPA ---
            - sed -i '1s/^\xEF\xBB\xBF//' "${HPA_PATH}"
            - yq e ".spec.scaleTargetRef.name = \"${ROLLBACK_DEPLOYMENT}\"" -i "${HPA_PATH}"
            - kubectl apply -f "${HPA_PATH}"

            - echo "âœ… Rollback complete."