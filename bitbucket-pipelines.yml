pipelines:
  branches:
    dev:
      - step:
          name: üèóÔ∏è Build and Push Docker Image
          runs-on:
            - self.hosted
            - linux.shell
          script:
            # Mandate the use of the host's UNIX socket for Docker communication
            - export DOCKER_HOST=unix:///var/run/docker.sock
            
            - echo "Logging in to Docker Hub..."
            - echo "$DOCKERHUB_PASSWORD" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

            - IMAGE_NAME="${DOCKERHUB_USERNAME}/automation-project"
            - VERSION="prod-0.1.${BITBUCKET_BUILD_NUMBER}"
            - VERSIONED_IMAGE="${IMAGE_NAME}:${VERSION}"

            - echo "Building Docker image..."
            - docker build -t "${IMAGE_NAME}:latest" .
            - docker tag "${IMAGE_NAME}:latest" "${VERSIONED_IMAGE}"

            - echo "Pushing images..."
            - docker push "${IMAGE_NAME}:latest"
            - docker push "${VERSIONED_IMAGE}"
            - echo "Image pushed successfully!"

      - step:
          name: üöÄ Deploy to Kubernetes Cluster
          runs-on:
            - self.hosted
            - linux.shell # Targeting the Shell Runner
          deployment: Production
          script:
            # --- Kubernetes Deployment ---
            
            # NOTE: Assumes 'kubectl' is installed and configured on the Shell Runner VM.
            # Assumes a 'k8s/deployment.yaml' file exists in the repo with an <IMAGE_PLACEHOLDER>.

            # 1. Define the full image tag
            # We use the versioned image for the deployment to ensure rolling updates
            - DEPLOY_IMAGE="${DOCKERHUB_USERNAME}/automation-project:${VERSIONED_IMAGE}"
            
            # 2. Patch the YAML file by replacing the placeholder tag
            # This is the core CD action: injecting the new image name
            - echo "Injecting image tag ${DEPLOY_IMAGE} into manifest..."
            - sed -i "s|<IMAGE_PLACEHOLDER>|${DEPLOY_IMAGE}|g" k8s/deployment.yaml
            
            # 3. Apply the updated manifest to the Kubernetes cluster
            - echo "Applying Kubernetes deployment via kubectl..."
            - kubectl apply -f k8s/deployment.yaml
            
            # 4. Wait for the deployment to finish rolling out (professional practice)
            - kubectl rollout status deployment/automation-project-deployment
            
            - echo "‚úÖ Deployment to Kubernetes successful! New version"